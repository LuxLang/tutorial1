##  Copyright (c) Eduardo Julian. All rights reserved.
##  This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
##  If a copy of the MPL was not distributed with this file,
##  You can obtain one at http://mozilla.org/MPL/2.0/.

(;import lux
         (lux (control monad
                       eq)
              (data maybe
                    [list #* "" List/Functor List/Fold]
                    [text "Text/" Text/Monoid Text/Eq]
                    [number "Int/" Int/Codec@Text]
                    error
                    [product]
                    text/format)
              (codata io)
              host
              (concurrency async)
              [cli #+ program:]
              [hack])
         (. ["&&" core]
            ["&&;" state]
            ["&&;" util]
            ["&&;" ui]
            (server ["&&server" core]
                    ["&&server-host" host])))

## [Utils]
(def: (error->maybe input)
  (All [a] (-> (Error a) (Maybe a)))
  (case input
    (#;Left _)
    #;None

    (#;Right output)
    (#;Some output)
    ))

## [Program]
(def: (handler state req)
  (-> &&state;AppState &&server;RequestHandler)
  (let [(\slots [#&&server;request-method
                 #&&server;request-uri
                 #&&server;request-headers
                 #&&server;request-params
                 #&&server;request-body]) req]
    (case request-uri
      (\~ &&util;css-path)
      (:: Async/Monad wrap (&&server;css-response &&ui;css))
      
      _
      (do Async/Monad
        [#let [referer (? &&util;default-referer
                          (&&server;get-header "Referer" request-headers))
               same-url? (Text/= (Text/++ &&util;default-host request-uri) referer)]
         [succeded? refer?] (: (Async [Bool Bool])
                               (? (wrap [(= 0 (size request-params)) false])
                                  (: (Maybe (Async [Bool Bool]))
                                     (case request-uri
                                       (\~ &&util;toggle-path)
                                       (do Maybe/Monad
                                         [id' (&&server;get-param "id" request-params)
                                          id (error->maybe (Int/decode id'))]
                                         (wrap (do Async/Monad
                                                 [success (future (&&state;toggle-task id state))]
                                                 (wrap [success true]))))
                                       
                                       (\~ &&util;delete-path)
                                       (do Maybe/Monad
                                         [id' (&&server;get-param "id" request-params)
                                          id (error->maybe (Int/decode id'))]
                                         (wrap (do Async/Monad
                                                 [success (future (&&state;delete-task id state))]
                                                 (wrap [success true]))))

                                       (\~ &&util;clear-completed-path)
                                       (do Maybe/Monad
                                         []
                                         (wrap (do Async/Monad
                                                 [success (future (&&state;clear-completed state))]
                                                 (wrap [success true]))))
                                       
                                       _
                                       (do Maybe/Monad
                                         [task-desc (&&server;get-param "todo" request-params)]
                                         (if (Text/= "" task-desc)
                                           (wrap (:: Async/Monad wrap [true true]))
                                           (wrap (do Async/Monad
                                                   [success (if same-url?
                                                              (future (&&state;add-task task-desc state))
                                                              (wrap true))]
                                                   (wrap [success true]))))
                                         )))))
         show-clear-completed? (future (&&ui;show-clear-completed? state))
         tasks (: (Async &&state;AppData) (future (&&state;get-task-list state)))
         #let [tasks-left (|> tasks (filter (. &&state;active-task? product;right)) size)
               display-filter (case request-uri
                                (\~ &&util;all-path)       #&&ui;All
                                (\~ &&util;active-path)    #&&ui;Active
                                (\~ &&util;completed-path) #&&ui;Completed
                                _                          #&&ui;All)
               tasks-to-show (&&ui;filter-tasks display-filter tasks)
               output-page (&&ui;page$ (&&ui;todo$ show-clear-completed? tasks-left display-filter tasks-to-show))]]
        (wrap (if (and refer?
                       (not same-url?))
                (&&server;redirect referer)
                (&&server;html-response output-page)))))
    ))

(program: args
  (do IO/Monad
    [app-state &&state;gen-state
     _ (&&server-host;deploy-server &&util;server-port (handler app-state))]
    (wrap (hack;log! "Server is running!"))))
