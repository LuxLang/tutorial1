##  Copyright (c) Eduardo Julian. All rights reserved.
##  This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
##  If a copy of the MPL was not distributed with this file,
##  You can obtain one at http://mozilla.org/MPL/2.0/.

(;import lux
         (lux (control monad
                       eq)
              (data maybe
                    [list "" List/Functor]
                    [dict]
                    [product]
                    [number])
              (codata [io #- run])
              host
              (concurrency [stm])
              [hack])
         (.. ["&" core]))

## [Types]
(type: #export AppState
  {#;doc "The next-ID for a task, and the collection of tasks."}
  (stm;Var [Int (dict;Dict Int &;Task)]))

(type: #export AppData
  {#;doc "App-data, as can be rendered onto HTML."}
  (List [Int &;Task]))

## [Values]
(def: #export gen-state
  {#;doc "A procedure for generating an initial app-state."}
  (IO AppState)
  (io (stm;var [0 (dict;new number;Int/Hash)])))

(do-template [<name> <filter> <post>]
  [(def: #export <filter>
     (-> &;Task Bool)
     (|>. (get@ #&;completed?)
          <post>))

   (def: #export <name>
     (-> AppData Int)
     (|>. (list;filter (|>. product;right <filter>))
          list;size))]

  [num-active-tasks    active-task?    not]
  [num-completed-tasks completed-task? id]
  )

(def: #export (get-task-list !state)
  (-> AppState (IO AppData))
  (do IO/Monad
    [[next-id data] (stm;read! !state)]
    (wrap (list;sort (lambda [[idl _] [idr _]] (< idl idr))
                     (dict;entries data)))))

(def: #export (add-task task-desc !state)
  (-> Text AppState (IO Bool))
  (do IO/Monad
    [[next-id data] (stm;read! !state)
     #let [task {#&;completed? false
                 #&;description task-desc}
           data' (dict;put next-id task data)]
     _ (stm;write! [(inc next-id) data']
                   !state)]
    (wrap true)))

(def: #export (toggle-task idx !state)
  (-> Int AppState (IO Bool))
  (do IO/Monad
    [[next-id data] (stm;read! !state)]
    (case (dict;get idx data)
      (#;Some task)
      (do %
        [#let [data' (dict;put idx (update@ #&;completed? not task) data)]
         _ (stm;write! [next-id data'] !state)]
        (wrap true))

      #;None
      (:: IO/Monad wrap false))))

(def: #export (delete-task idx !state)
  (-> Int AppState (IO Bool))
  (do IO/Monad
    [[next-id data] (stm;read! !state)]
    (case (dict;get idx data)
      (#;Some task)
      (do %
        [_ (stm;write! [next-id (dict;remove idx data)] !state)]
        (wrap true))

      #;None
      (:: IO/Monad wrap false))))

(def: #export (clear-completed state)
  (-> AppState (IO Bool))
  (do IO/Monad
    [task-list (get-task-list state)
     _ (|> task-list
           list;reverse
           (map% %
                 (: (-> [Int &;Task] (IO Bool))
                    (lambda [[idx task]]
                      (if (completed-task? task)
                        (delete-task idx state)
                        (wrap true))))))]
    (wrap true)))
